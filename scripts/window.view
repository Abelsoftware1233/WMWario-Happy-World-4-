// Functie om de achtergrondpositie te wijzigen op basis van de X-positie van Mario
// Deze functie moet buiten de Window.view loop staan, maar binnen dezelfde scope.
function updateBackground(marioX) {
    // Zorg ervoor dat dit de ID van je game container is uit de HTML
    const gameContainer = document.getElementById('gameContainer'); 
    
    if (gameContainer) {
        // De Mario beweegt meestal rond een vast punt op het scherm (bijv. 20% of 30%).
        // We moeten berekenen hoeveel de ACHTERGROND moet verschuiven.
        // We nemen Mario's X-positie (relatief aan de wereld) en delen deze door een factor (parallaxFactor).

        // Pas deze factor aan: 1.0 = achtergrond beweegt even snel als Mario (geen viewport), 0.5 = parallax-effect
        const parallaxFactor = 1.0; 
        
        // De achtergrond moet de tegengestelde richting op bewegen
        const backgroundShiftX = -marioX * parallaxFactor; 
        
        // Pas de CSS property aan op de game-container
        gameContainer.style.backgroundPositionX = `${backgroundShiftX}px`;
    }
}


// De hoofd game-loop functie
Window.view = function() {
    
    // De 'this' context is Window.model (vanwege de bind onderaan)
    const model = this; 

    model.renders = (model.renders + 1) % 100;
    model.lastRender = new Date().getTime();

    // Zoek Mario op om de achtergrond te sturen (dit is een aanname, pas aan indien nodig)
    let marioX = 0; 
    
    // Render elk object.
    for (var x = 0; x < model.objects.length; ++x) {
        var thisObject = model.objects[x];
        if (!thisObject) {
            continue;
        }

        // --- 1. Snelheden berekenen ---
        
        // Horizontale snelheid (V = V0 + A)
        if (thisObject.horizontalAcceleration) {
            thisObject.set(
                'horizontalVelocity',
                Math.min(
                    Math.max(
                        thisObject.horizontalVelocity + thisObject.horizontalAcceleration,
                        -1 * thisObject.maxHorizontalVelocity
                    ),
                    thisObject.maxHorizontalVelocity
                )
            );
        }
        
        // Verticale snelheid (V = V0 + A)
        if (thisObject.verticalAcceleration) {
            thisObject.set(
                'verticalVelocity',
                Math.min(
                    Math.max(
                        thisObject.verticalVelocity + thisObject.verticalAcceleration,
                        -1 * thisObject.maxVerticalVelocity
                    ),
                    thisObject.maxVerticalVelocity
                )
            );
        }

        // --- 2. Posities en Botsingen berekenen ---

        // Y-coördinaat. (Eerst Y controleren i.v.m. zwaartekracht/springen)
        if (thisObject.verticalVelocity) {
            var newY = thisObject.y + thisObject.verticalVelocity;
            
            // Controleer of het object op de grond is (Y <= 0)
            if (newY <= 0) {
                thisObject.set('falling', false);
                thisObject.set('verticalVelocity', 0);
                thisObject.set('y', 0); // Zet Y op de grond
            }
            else {
                thisObject.set('falling', true);
                thisObject.set('y', newY);

                // Botsingsdetectie: Y
                if (thisObject.collisionY) {
                    for (var y = 0; y < model.objects.length; ++y) {
                        var thatObject = model.objects[y];
                        if (
                            x === y ||
                            !thatObject ||
                            thatObject.static ||
                            !thisObject.isInside(thatObject)
                        ) {
                            continue;
                        }
                        thisObject.collisionY(thatObject);
                    }
                }
            }
        }

        // X-coördinaat.
        if (thisObject.horizontalVelocity) {
            thisObject.set('x', thisObject.x + thisObject.horizontalVelocity);

            // Botsingsdetectie: X
            if (thisObject.collisionX) {
                for (var y = 0; y < model.objects.length; ++y) {
                    var thatObject = model.objects[y];
                    if (
                        x === y ||
                        !thatObject ||
                        thatObject.static ||
                        !thisObject.isInside(thatObject)
                    ) {
                        continue;
                    }
                    thisObject.collisionX(thatObject);
                }
            }
        }
        
        // --- 3. Controllers en View Updaten ---
        
        // Roep de controller aan (input/AI logica)
        if (thisObject.controller) {
            thisObject.controller();
        }
        
        // Roep de view aan (CSS/DOM updaten)
        thisObject.view();
        
        // Sla Mario's X-positie op voor achtergrondbesturing
        // We gaan ervan uit dat het eerste object in de array de speler is, of dat je een methode hebt om deze te identificeren.
        if (x === 0) { // WAARSCHIJNLIJK de speler
            marioX = thisObject.x;
        }
    }
    
    // --- 4. ACHTERGROND UPDAET (De Fix!) ---
    // Update de achtergrond op basis van de X-positie van Mario
    updateBackground(marioX);


    // --- 5. Game Loop Timer ---
    // 60 FPS: 1000ms / 60 = ~16.67ms per frame
    setTimeout(
        Window.view,
        Math.max(0, 17 - new Date().getTime() + model.lastRender)
    );
}.bind(window.model);
